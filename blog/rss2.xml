<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>windgodm</title>
    <link>https://windgodm.github.io/blog/</link>
    
    <atom:link href="https://windgodm.github.io/blog/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 22 Apr 2021 17:09:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CPP编写类库给其他语言使用的总结</title>
      <link>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/</link>
      <guid>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/</guid>
      <pubDate>Thu, 22 Apr 2021 17:05:59 GMT</pubDate>
      
      <description>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。,&lt;br&gt;目的是一次编写与编译某个类库，然后给多语言使用。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="CPP编写类库给其他语言使用"><a href="#CPP编写类库给其他语言使用" class="headerlink" title="CPP编写类库给其他语言使用"></a>CPP编写类库给其他语言使用</h1><p>主要是使用vs2019作为ide，cpp为语言编写类库，然后编译成dll，供其他cpp、c#、python等语言的工程调用类库。目的是一次编写与编译某个类库，然后给多语言使用。</p><p>这里是个傻瓜式操作总结贴（我总是忘记细节emm），总结网上及书里提供的一些方法，尽量用简单的方式实现目的。</p><h2 id="用cpp写类库（VS2019）"><a href="#用cpp写类库（VS2019）" class="headerlink" title="用cpp写类库（VS2019）"></a>用cpp写类库（VS2019）</h2><h3 id="类库项目"><a href="#类库项目" class="headerlink" title="类库项目"></a>类库项目</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>直接新建空白项目，然后在项目属性页中进行如下配置：</p><blockquote><p>常规-常规属性-配置类型：动态库(.dll)</p></blockquote><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><p>下面给出项目的框架。直接编译就可以得到MyDll.dll</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDll）：头文件：MyDll.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYDLL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYDLL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是输出的函数</span></span><br><span class="line">_declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是输出的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">declspec</span>(<span class="title">dllexport</span>) <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass();</span><br><span class="line">    ~MyClass();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !MYDLL_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDll）：源文件：MyDll.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现头文件中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现头文件中类的函数</span></span><br><span class="line">MyClass::MyClass()</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyClass::~MyClass()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyClass::Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[index] = x;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] + a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加类库对应的共享项目"><a href="#添加类库对应的共享项目" class="headerlink" title="添加类库对应的共享项目"></a>添加类库对应的共享项目</h3><p>这一步的目的主要是为了解决<strong>调用类库项目</strong>和<strong>类库项目</strong> <strong>不在同一个解决方案</strong>的情况。</p><p>在同一个解决方案中，新建一个<strong>共享项目</strong>项目，然后在<strong>解决方案资源管理器</strong>-<strong>共享项目</strong>上右键<strong>添加</strong>-<strong>添加现有项</strong>，找到MyDll.h、MyDll.cpp添加进去。</p><h2 id="cpp项目-调用-cpp写的类库（VS2019）"><a href="#cpp项目-调用-cpp写的类库（VS2019）" class="headerlink" title="cpp项目 调用 cpp写的类库（VS2019）"></a>cpp项目 调用 cpp写的类库（VS2019）</h2><h3 id="方案一：隐式链接"><a href="#方案一：隐式链接" class="headerlink" title="方案一：隐式链接"></a>方案一：隐式链接</h3><ul><li><p><strong>添加引用：</strong><br>在<strong>解决方案资源管理器</strong>中<strong>你的cpp项目</strong>的<strong>引用</strong>处右键选择<strong>添加引用</strong></p><ul><li>cpp项目和dll项目在<strong>同一个解决方案</strong>：<br>然后在弹出窗口的左侧菜单选择<strong>项目</strong>-<strong>解决方案</strong>，然后找到刚刚写好的<strong>dll项目</strong>，点击勾选框。</li><li>两者不在同一个解决方案：<br>先参考<strong>cpp写类库</strong>-<strong>配置共享项目</strong>配置好，然后在弹出窗口的左侧菜单选择<strong>共享的项目</strong>-<strong>解决方方案</strong>，找到<strong>dll项目对应的共享项目</strong>，点击勾选框。</li></ul></li><li><p><strong>包含头文件</strong>：通过相对或绝对<strong>路径引用</strong>dll项目的头文件。</p></li></ul><h3 id="方案二：显示链接"><a href="#方案二：显示链接" class="headerlink" title="方案二：显示链接"></a>方案二：显示链接</h3><p>没有需求，所以还没有测试这种方案这么处理比较方便。// todo</p><h2 id="C-（WPF）项目-调用-cpp写的类库（vs2019）"><a href="#C-（WPF）项目-调用-cpp写的类库（vs2019）" class="headerlink" title="C#（WPF）项目 调用 cpp写的类库（vs2019）"></a>C#（WPF）项目 调用 cpp写的类库（vs2019）</h2><p>我的情况是涉及一个大量使用指针的类。通过一个托管类把类的函数都暴露出来，实际上就是在托管类中做一个跳转，有时候还需要在这个跳转的函数中做c#和c++间的类型转换。</p><p>流程大概是先写个托管类，然后再在wpf项目中导入。</p><p>需要<strong>注意</strong>的是，Debug调试时，应该把 MyDll.dll 放到WPF的 /bin/Debug 目录中，原因是 MyDllCSWrapper.dll 需要导入 MyDll.dll。所以需要把 <strong>MyDll.dll</strong> 放到项目的<strong>可执行文件的根目录</strong>（当然系统目录啥的好像也行）。<br>至于MyDllCSWrapper.dll放哪里都行，c#中ImportDll的路径填对就行。</p><h3 id="托管类"><a href="#托管类" class="headerlink" title="托管类"></a>托管类</h3><p>首先参考“用cpp写类库”新建一个项目写托管。</p><p>这里直接给出托管类代码框架，原型类参考前面“用cpp写类库”。</p><p>这里MyDll.h中的Add不是类中的函数，我没有这个需求没有去研究，不确定该如何暴露，欢迎补充。// todo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDllCSWrapper）：头文件：MyDllCSWrapper.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里通过相对或绝对路径引用MyDll的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../MyDll/MyDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyDllCSWrapper</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 项目（MyDllCSWrapper）：源文件：MyDllCSWrapper.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyDllCSWrapper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyDllCSWrapper</span><br><span class="line">&#123;</span><br><span class="line">MyClass* pmc = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ppe-&gt;Set(index, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>c++中的类型与c#不是完全对应的。int、double、float啥的好像是一一对应的，但指针就不一定了，要小心处理。</p><p>我遇到的一个特殊情况就是我需要传递一个数组过去，c#中使用类型 char[]、ref char[] 只能传递第一个元素过去。需要使用 byte[] 才行。</p><p>下面是我遇到一些的情况。</p><blockquote><p>c++类型 —- c# 类型</p><p>unsigned int、unsigned long、DWORD —- uint</p><p>char*（数组）—- byte[]</p></blockquote><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>暂时没有需求，没有了解，可能下个星期就会需要。// todo</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/Programing/">Programing</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/Programing/">Programing</category>
      
      <category domain="https://windgodm.github.io/blog/tags/cpp/">cpp</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/23/CppDllForOthers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>games101笔记</title>
      <link>https://windgodm.github.io/blog/2021/04/21/games101Note/</link>
      <guid>https://windgodm.github.io/blog/2021/04/21/games101Note/</guid>
      <pubDate>Wed, 21 Apr 2021 10:36:58 GMT</pubDate>
      
      <description>cg入门课程games101的笔记，内容比较随缘，有重点内容会单独写,&lt;br&gt;只是个人爱好，大概率会咕咕咕,&lt;br&gt;更新到第二课</description>
      
      
      
      <content:encoded><![CDATA[<p>更新到第二课</p><p><a href="/blog/note/games101Note.html">games 101 note</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/ComputerGraphics/">ComputerGraphics</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      <category domain="https://windgodm.github.io/blog/tags/ComputerGraphics/">ComputerGraphics</category>
      
      <category domain="https://windgodm.github.io/blog/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/">持续更新中</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/21/games101Note/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>反射式dll注入源码笔记</title>
      <link>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/</link>
      <guid>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/</guid>
      <pubDate>Sun, 11 Apr 2021 10:31:55 GMT</pubDate>
      
      <description>读msf的反射注入源码学习了下反射注入,&lt;br&gt;学习了下pe结构和windows加载模块的过程，如填写iat、重定位</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="从反射注入学习pe文件加载"><a href="#从反射注入学习pe文件加载" class="headerlink" title="从反射注入学习pe文件加载"></a>从反射注入学习pe文件加载</h1><h2 id="前言？后记与总结"><a href="#前言？后记与总结" class="headerlink" title="前言？后记与总结"></a>前言？后记与总结</h2><p>这是我写完代码后写的总结。重新梳理一下反射注入到底想干什么、以及怎么干。以及从中学到了什么。</p><h3 id="收获？目标？反射注入是什么"><a href="#收获？目标？反射注入是什么" class="headerlink" title="收获？目标？反射注入是什么"></a>收获？目标？反射注入是什么</h3><p>首先是学习反射注入的收获，当然也可以作为学习的目标，同时也是反射注入实际做的东西。</p><p>我的理解是反射注入实际上就是手工加载模块。通过LoadLibrary加载dll会在peb中留下记录，通过手工实现加载过程，我们的dll能像正常dll那样工作，且不再peb中留下痕迹。</p><p>也就是说，通过学习反射注入，可以了解到windows系统加载一个pe文件的流程。其中涉及到了部分的peb以及大量的pe结构。</p><p>我们主要需要peb中的ldr结构，这个结构中保存了该进程已经加载了的dll。</p><p>既然我们的主要工作是手工加载pe文件，自然要对pe文件格式有一定了解。但笔记中不会多提pe文件结构，实际上只要大概了解pe文件格是是个什么，然后在写代码时多去看pe结构的定义，就可以对pe文件结构有一个更深的理解。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>在学习过程中参考了许多资料，最主要的就是msf的反射注入payload的源码。其他如有不懂通过百度也可以找到详细的解释。相关文章比较多，dddd，就不一一列举了。</p><h3 id="关于这篇东西"><a href="#关于这篇东西" class="headerlink" title="关于这篇东西"></a>关于这篇东西</h3><p>这篇东西由我阅读源码，查资料时做的笔记发展而来。国内虽然少但也有一些优秀的反射注入的文章，看雪中也有类似文章，但阅读门槛稍微有点高。因为是由笔记发展而来，这更像是一个零基础初学者的学习笔记（实际上在开始学反射注入之前，只知道pe文件格是是什么东西，几乎完全不了解。对windows的机制也完全不了解），希望能帮助到初学者，这项技术对我学习windows有很大帮助，虽然我只是一个初学者，但这项实践使我之后对书本、资料上的内容有了更深的了解。可能会有错误，希望发现错误的dalao可以帮帮我这个初学者纠正。</p><h3 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h3><p>va、fa、rva这几个概念搞清楚好像就行。实际上就是对pe文件如何从文件映射到内存有一个大体的认识。我们的工作就是具体完成这个过程。可以参考下图。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0exl4.png" alt="pe文件到内存的映射"></p><p>pe文件的格式网上有比较多的图片，这里就不贴了。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(前置条件序号) 序号 流程内容</span><br><span class="line"></span><br><span class="line">============</span><br><span class="line">注入器：</span><br><span class="line">============</span><br><span class="line">(0)   1 打开dll文件(CreateFile)，获取dll长度(GetFileSize)</span><br><span class="line">(1)   2 分配内存(HealAlloc)，读取文件(ReadFile)</span><br><span class="line">(0)   3 打开目标进程(OpenProcess)</span><br><span class="line">(2,3) 4 调用反射注入函数(LoadLibraryR.c&gt;LoadRemoteLibraryR)</span><br><span class="line">(2)   5 获取反射加载函数的文件偏移(LoadLibraryR.c&gt;GetReflectiveLoaderOffset)</span><br><span class="line">(2,3) 6 在目标进程中分配空间(VirtualAllocEx)，写入dll(WriteProcessMemory)</span><br><span class="line">(6)   7 修改目标进程中的空间为可执行(VirtualProtectEx)</span><br><span class="line">(5,7) 8 创建远程线程，执行反射加载函数(CreateRemoteThread)</span><br><span class="line"></span><br><span class="line">=======================</span><br><span class="line">反射加载函数（运行在被注入进程的新建线程中）：</span><br><span class="line">=======================</span><br><span class="line">1 获取基地址</span><br><span class="line">2 获取需要的kernel32.dll及ntdll.dll的函数的va</span><br><span class="line">3 分配空间作为映像空间，并复制pe头到新的位置</span><br><span class="line">4 复制所有段到映像的对应位置</span><br><span class="line">5 处理导入表，填写iat</span><br><span class="line">6 重定位</span><br><span class="line">7 跳转到ep（_DllMainCRTStartup）</span><br><span class="line">8 返回entry point地址</span><br></pre></td></tr></table></figure><h2 id="注入器"><a href="#注入器" class="headerlink" title="注入器"></a>注入器</h2><h3 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h3><p>首先打开dll文件，获取长度，并在堆中分配空间读取文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hFile = CreateFileW(dllPathname, GENERIC_READ, <span class="number">0</span>, <span class="number">0</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>);</span><br><span class="line">dwDllLen = GetFileSize(hFile, <span class="number">0</span>);</span><br><span class="line">lpDll = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, dwDllLen);</span><br></pre></td></tr></table></figure><p>然后找到dll中ReflectiveLoader的入口点。</p><p>最后以RW申请空间，写入dll后改成RX，然后以ReflectiveLoader作为线程函数创建远程线程。</p><h3 id="计算fa"><a href="#计算fa" class="headerlink" title="计算fa"></a>计算fa</h3><p>LoadLibraryR中有个函数Rva2Offset用于获取rva对应的fa。</p><p>原理是遍历区块获取区块的section_rva和section_fa，然后比较rva和section_rva找到rva所在的section，最后计算出fa。再用fa+baseAddr得到内存中的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">Rva2Fa</span><span class="params">(DWORD rva, PIMAGE_SECTION_HEADER sections, <span class="keyword">int</span> sectionNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectionNum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sectionVa = sections[i].VirtualAddress;</span><br><span class="line">        <span class="keyword">if</span> ((rva &gt;= sectionVa) &amp;&amp; ((sectionVa + sections[i].SizeOfRawData) &gt; rva))</span><br><span class="line">            <span class="keyword">return</span> rva - (sectionVa - sections[i].PointerToRawData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取ReflectivelLoader位置（输出表）"><a href="#获取ReflectivelLoader位置（输出表）" class="headerlink" title="获取ReflectivelLoader位置（输出表）"></a>获取ReflectivelLoader位置（输出表）</h3><p>通过nt头，计算出sections的fa，以及通过nt头的optionalheader获取输出表的rva。</p><p>然后遍历section找到输出表的fa，接着遍历输出表的函数名字rva表，计算出rva对应fa得到导出函数名字，与需要的导出函数做对比，确定要找的函数在函数名表中的下标。用此下标在序号表中找到序号，最后再用序号去地址表找到地址。</p><h2 id="反射加载函数"><a href="#反射加载函数" class="headerlink" title="反射加载函数"></a>反射加载函数</h2><h3 id="1-获取基址"><a href="#1-获取基址" class="headerlink" title="1. 获取基址"></a>1. 获取基址</h3><p>首先获取代码的位置，然后再往前找dos头。</p><p>_ReturnAddress()返回当前调用函数的返回地址。所以在loader中调用一个函数，该函数再调用_ReturnAddress()，返回调用函数的返回地址，即loader中调用函数的下一条语句的地址。<br>其中 __declspec(noinline) 用于防止编译器优化该函数成内联函数，否则返回的就是loader的返回地址。</p><p>使用_ReturnAddress需要intrin.h，并使用#pragma intrinsic防止内联优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> intrinsic(_ReturnAddress)</span></span><br><span class="line">__declspec(noinline) <span class="function">PVOID <span class="title">NextAddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (PVOID)_ReturnAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据pe格式可知，dos头(IMAGE_DOS_HEADER)中有有一个e_magic标志，值是0x5A4D(MZ)。<br>所以向前遍历内存，直到找到MZ标志，再检查pe头的PE标志，这样就找到dos头了。<br>需要注意的是，检查PE标志时要检查pe头偏移是否正确，防止错误的内存访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dosHeadAddr-&gt;e_magic == <span class="number">0x5A4D</span>) &#123;</span><br><span class="line">        LONG e_lfanew = dosHeadAddr-&gt;e_lfanew;</span><br><span class="line">        <span class="keyword">if</span> (e_lfanew &gt;= <span class="keyword">sizeof</span>(IMAGE_DOS_HEADER) &amp;&amp; e_lfanew &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">            ntHeadAddr = (PIMAGE_NT_HEADERS)((PVOID)dosHeadAddr + (PVOID)e_lfanew);</span><br><span class="line">            <span class="keyword">if</span> (ntHeadAddr-&gt;Signature == <span class="number">0x4550</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dosHeadAddr--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也可以取巧，远程线程是可以传递一个参数的，对于我们这个简单的dll，imagebase实际上就是分配空间的首地址，可以作为参数传入。</p><h3 id="2-获取需要的内核导出函数的va"><a href="#2-获取需要的内核导出函数的va" class="headerlink" title="2. 获取需要的内核导出函数的va"></a>2. 获取需要的内核导出函数的va</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>接下来的步骤中需要用到一些ntdll.dll，kernel32.dll中的导出函数，所以需要先找到这些函数的va。这些系统模块都是已经加载了的，可以在peb中找到其加载的位置。</p><p>这里利用hash避免直接比较字符串。</p><p>我们需要LoadLibraryA、GetProcAddress加载导入表中的dll的对应的函数。</p><p>需要VirtualAlloc分配内存给我们把pe文件加载到其中。</p><p>需要NtFlushInstructionCache刷新指令缓存。</p><h4 id="LDR-DATA-TABLE-ENTRY"><a href="#LDR-DATA-TABLE-ENTRY" class="headerlink" title="LDR_DATA_TABLE_ENTRY"></a>LDR_DATA_TABLE_ENTRY</h4><p>InMemoryOrderModuleList对应的链表是一个环形双向链表，且有一个头节点（或者说哨兵节点）。InMemoryOrderModuleList的Flink指向链表的第一个节点，Blink指向链表最后一个节点。头节点的Flink是第一个节点，可以以此为跳出条件遍历该链表。</p><p><img src="https://z3.ax1x.com/2021/04/11/c0mZ1e.jpg" alt="ldr链"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先从peb中找到ldr，然后遍历InMemoryOrderModuleList，通过hash(BaseName)找到kernel32.dll和ntdll.dll对应的LDR_DATA_TABLE_ENTRY结构。</p><p>找到dll对应的LDR_DATA_TABLE_ENTRY后，获取其imagebase，然后解析pe头，计算出导出表位置。同样利用hash比较字符串找到所需的导出函数，并计算出va。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找pLdrDataTableEnrty</span></span><br><span class="line">DWORD pPeb = __readfsdword(<span class="number">0x30</span>);</span><br><span class="line">DWORD pLdr = *(DWORD*)(pPeb + <span class="number">0xc</span>);</span><br><span class="line">DWORD pInMemoryOrderModuleList = pLdr + <span class="number">0x14</span>; <span class="comment">// 第一个节点的二级指针</span></span><br><span class="line">DWORD pLdrDataTableEnrty = *(DWORD*)(pInMemoryOrderModuleList + <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 遍历LdrDataTableEnrty</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">WCHAR* name = (WCHAR*)*(DWORD*)(pLdrDataTableEnrty + <span class="number">0x24</span> + <span class="number">0x4</span>);</span><br><span class="line">hash = YourHashFun(name); <span class="comment">// 使用你自己的函数计算hash值</span></span><br><span class="line"><span class="keyword">if</span>(hash == DLLHASH) &#123; <span class="comment">// DLLHASH由你自己的函数计算得出</span></span><br><span class="line">DWORD baseAddr = *(DWORD*)(pLdrDataTableEnrty + <span class="number">0x10</span>);</span><br><span class="line"><span class="comment">// 解析pe头过程省略</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; funcNum; i++) &#123; <span class="comment">// funcNum是导出函数的个数</span></span><br><span class="line"><span class="keyword">char</span>* name = (<span class="keyword">char</span>*)(baseAddr + ((DWORD*)nameRvas)[i]);</span><br><span class="line">DWORD hash = YourHashFun(name);</span><br><span class="line"><span class="keyword">if</span> (hash == FUNCHASH) &#123;</span><br><span class="line">pFunc = (FUNC)(baseAddr + ((DWORD*)funcRvas)[((WORD*)ordRvas)[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(*(DWORD*)(pLdrDataTableEnrty) != *(DWORD*)(pInMemoryOrderModuleList))</span><br></pre></td></tr></table></figure><h3 id="3-给映像分配空间，并加载pe头"><a href="#3-给映像分配空间，并加载pe头" class="headerlink" title="3. 给映像分配空间，并加载pe头"></a>3. 给映像分配空间，并加载pe头</h3><p>新分配大小等于sizeOfImga的内存作为映像加载的空间，然后把pe头复制到新内存里，这里我只更新了新nt头的imagebase地址。太简单就不贴代码了。</p><h3 id="4-加载段"><a href="#4-加载段" class="headerlink" title="4. 加载段"></a>4. 加载段</h3><p>遍历section_header获取fa和rva，计算出section在旧内存中的va和新内存中的va。然后复制section到新内存中的对应位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldVA = oldImageBase + sections[i].PointerToRawData;</span><br><span class="line">newVA = newImageBase + sections[i].VirtualAddress; </span><br></pre></td></tr></table></figure><h3 id="5-处理导入表"><a href="#5-处理导入表" class="headerlink" title="5. 处理导入表"></a>5. 处理导入表</h3><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>找到导入表，然后遍历导入表，依次加载对应的dll，及需要的dll的导出函数，并填写对应iat。</p><h4 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// winnt.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">// PIMAGE_IMPORT_BY_NAME (补充一下，这是个rva)</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;</span><br><span class="line">    CHAR   Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>和导出表不同，导入表是一个结构体数组。它不提供结构体数量，最后一个结构体仅作为结束标志，不包含导入信息，其成员Characteristics为0，这可以作为遍历的退出条件。</p><p>对于每个导入表，在文件中时OriginalFirstThunk和FirstThunk都是RVA，指向同一个IMAGE_THUNK_DATA结构体数组。<br>当加载到内存时，FirstThunk改为函数的VA，即iat。</p><p>文件中时，OriginalFirstThunk和FirstThunk指向的结构体数组中，每一个IMAGE_THUNK_DATA的成员u1都被解释为Ordinal，若该函数应该通过序号导入，则Ordinal的最高位会被置为1。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>见实现代码注释。</p><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; pImportDescriptor-&gt;Characteristics; pImportDes++) &#123;</span><br><span class="line">    <span class="comment">// 加载dll</span></span><br><span class="line">    HMODULE libraryAddress = pLoadLibraryA((LPCSTR)((DWORD)pNewDosHeader + pImportDes-&gt;Name));</span><br><span class="line">    <span class="keyword">if</span> (!libraryAddress)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// parsing pe structure</span></span><br><span class="line">    PIMAGE_THUNK_DATA32 pOriginalThunk = (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;OriginalFirstThunk);</span><br><span class="line">    PIMAGE_THUNK_DATA32 pThunk = (PIMAGE_THUNK_DATA32)((DWORD)pNewDosHeader + pImportDes-&gt;FirstThunk);</span><br><span class="line">    PIMAGE_NT_HEADERS32 pLibNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)libraryAddress + ((PIMAGE_DOS_HEADER)libraryAddress)-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExportDir = (PIMAGE_EXPORT_DIRECTORY)((DWORD)libraryAddress + pLibNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    PDWORD funcRvas = (PDWORD)((DWORD)libraryAddress + pExportDir-&gt;AddressOfFunctions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*(DWORD*)pThunk) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pOriginalThunk &amp;&amp; pOriginalThunk-&gt;u1.Ordinal &amp; IMAGE_ORDINAL_FLAG) &#123;</span><br><span class="line">            <span class="comment">// import by ord</span></span><br><span class="line">            WORD ord = pOriginalThunk-&gt;u1.Ordinal - pExportDir-&gt;Base;</span><br><span class="line">            *(DWORD*)pThunk = ((DWORD)libraryAddress + funcRvas[ord]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// import by name (this is a rva)</span></span><br><span class="line">            *(DWORD*)pThunk = (DWORD)pGetProcAddress(libraryAddress, ((PIMAGE_IMPORT_BY_NAME)((DWORD)pNewDosHeader + pThunk-&gt;u1.AddressOfData))-&gt;Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pThunk++;</span><br><span class="line">        <span class="keyword">if</span> (pOriginalThunk)</span><br><span class="line">            pOriginalThunk++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-重定位"><a href="#6-重定位" class="headerlink" title="6. 重定位"></a>6. 重定位</h3><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>完成重定位过程。</p><h4 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h4><p>重定位表是一个结构体数组，DataDirectory中的重定位表项保存着第一个重定位表的rva，遍历每一个重定位表，并遍历重定位表中的表项，根据其重定位类型，执行重定位操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    WORD offset : <span class="number">12</span>;</span><br><span class="line">    WORD type : <span class="number">4</span>;</span><br><span class="line">&#125; RELOC;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">DWORD VA;</span><br><span class="line">DWORD size;</span><br><span class="line"><span class="comment">// RELOC reloc[];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><p>其中每一个重定位表保存着一个rva，重定位实际上就是遍历IMAGE_BASE_RELOCATION的成员reloc，然后执行<code>*(rva+baseAddr+reloc[i].offset) += baseAddr - ImageBase</code>。</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>两层循环，遍历重定位表，再遍历每个表的 RELOC reloc[]。然后根据重定位类型进行重定位。</p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析pe，并计算offset</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pDDBaseReloc = &amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];</span><br><span class="line">PIMAGE_BASE_RELOCATION pBaseRelocation;</span><br><span class="line">ULONG_PTR offset = (ULONG_PTR)pNewDosHeader - (ULONG_PTR)pNtHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pDDBaseReloc-&gt;Size) &#123;</span><br><span class="line">    DWORD size = pDDBaseReloc-&gt;Size;</span><br><span class="line">    pBaseRelocation = (PIMAGE_BASE_RELOCATION)((DWORD)pNewDosHeader + pDDBaseReloc-&gt;VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历重定位表结构体</span></span><br><span class="line">    <span class="keyword">while</span> (size &amp;&amp; pBaseRelocation-&gt;SizeOfBlock) &#123;</span><br><span class="line"></span><br><span class="line">        DWORD va = (DWORD)pNewDosHeader + pBaseRelocation-&gt;VirtualAddress;</span><br><span class="line">        DWORD num = (pBaseRelocation-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(IMAGE_RELOC); <span class="comment">// 计算reloc[]大小</span></span><br><span class="line">        PIMAGE_RELOC reloc = (PIMAGE_RELOC)((DWORD)pBaseRelocation + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历reloc[]，根据重定位类型重定位</span></span><br><span class="line">        <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">            DWORD type = reloc-&gt;type;</span><br><span class="line">            <span class="keyword">if</span> (type == IMAGE_REL_BASED_HIGH) &#123;</span><br><span class="line">                *(WORD*)(va + reloc-&gt;offset) += HIWORD(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == IMAGE_REL_BASED_LOW) &#123;</span><br><span class="line">                *(WORD*)(va + reloc-&gt;offset) += LOWORD(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (type == IMAGE_REL_BASED_HIGHLOW) &#123;</span><br><span class="line">                *(DWORD*)(va + reloc-&gt;offset) += (DWORD)offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reloc++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= pBaseRelocation-&gt;SizeOfBlock;</span><br><span class="line">        pBaseRelocation = (PIMAGE_BASE_RELOCATION)((DWORD)pBaseRelocation + pBaseRelocation-&gt;SizeOfBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-跳转到ep"><a href="#7-跳转到ep" class="headerlink" title="7. 跳转到ep"></a>7. 跳转到ep</h3><p>跳转到dll的ep。实际上就是执行dll原本的_DllMainCRTStartup函数。该函数会完成一些初始化工作并转到dllMain，让我们的dllMain像正常dllmain那样运行，但又不在peb中留下dll加载的痕迹。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* DLLMAIN)</span><span class="params">(HINSTANCE, DWORD, LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line">PVOID entryPoint = (PVOID)((DWORD)pNewDosHeader + pNewNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line"></span><br><span class="line">pNtFlushInstructionCache((HANDLE)<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">((DLLMAIN)entryPoint)((HMODULE)pNewDosHeader, DLL_PROCESS_ATTACH, lpParameter);</span><br></pre></td></tr></table></figure><h3 id="8-返回"><a href="#8-返回" class="headerlink" title="8. 返回"></a>8. 返回</h3><p>最后返回entrypoint。</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p>本文看雪链接：<a href="https://bbs.pediy.com/thread-266929.htm">https://bbs.pediy.com/thread-266929.htm</a></p><p>msf反射注入源码：<a href="https://github.com/rapid7/ReflectiveDLLInjection">https://github.com/rapid7/ReflectiveDLLInjection</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/windows/">windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/04/11/reflectiveDllInjection/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>vnctf21ReWp</title>
      <link>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/</link>
      <guid>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/</guid>
      <pubDate>Wed, 17 Mar 2021 11:03:13 GMT</pubDate>
      
      <description>vnctf2021 re部分题解（没有安卓那两题）</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="notsudoku"><a href="#notsudoku" class="headerlink" title="notsudoku"></a>notsudoku</h1><p>这题是python打包的exe</p><p>首先用pyinstxtractor解包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.\pyinstxtractor.py:86: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module&#x27;s documentation for alternative uses</span><br><span class="line">  import imp</span><br><span class="line">[*] Processing .\notsudoku.exe</span><br><span class="line">[*] Pyinstaller version: 2.1+</span><br><span class="line">[*] Python version: 37</span><br><span class="line">[*] Length of package: 5560832 bytes</span><br><span class="line">[*] Found 60 files in CArchive</span><br><span class="line">[*] Beginning extraction...please standby</span><br><span class="line">[+] Possible entry point: pyiboot01_bootstrap</span><br><span class="line">[+] Possible entry point: 2</span><br><span class="line">[*] Found 133 files in PYZ archive</span><br><span class="line">[*] Successfully extracted pyinstaller archive: .\notsudoku.exe</span><br><span class="line"></span><br><span class="line">You can now use a python decompiler on the pyc files within the extracted directory</span><br></pre></td></tr></table></figure><p>得到主要代码在文件 2 ，把这个文件改名为2.pyc，并复制struct文件的E3前面的内容，然后粘贴到2.pyc的E3前面。接着用uncompyle6反编译成py文件。</p><p>最后改一下变量名，得到的是要解一个五阶幻方。本来有多组解，因为有个校验所以只有唯一解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, sys, hashlib</span><br><span class="line"></span><br><span class="line">num = <span class="number">65</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 124 126</span></span><br><span class="line">print(<span class="string">&#x27;welcome baby~ input your flag~:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 128</span></span><br><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 130 132</span></span><br><span class="line">print(<span class="string">&#x27;your input is:&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 134</span></span><br><span class="line">print(<span class="string">&quot;let&#x27;s check......&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 136</span></span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 138 ~ 146</span></span><br><span class="line">list2 = []</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line">list2 += [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 148</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str1) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str1:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(i) &gt; <span class="number">52</span> <span class="keyword">or</span> <span class="built_in">ord</span>(i) &lt; <span class="number">48</span>: <span class="comment"># [0, 4]</span></span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">str</span>(hashlib.new(<span class="string">&#x27;md5&#x27;</span>, <span class="built_in">bytes</span>((str1), encoding=<span class="string">&#x27;utf8&#x27;</span>)).hexdigest())</span><br><span class="line"><span class="keyword">if</span> x[:<span class="number">6</span>] != <span class="string">&#x27;e3a912&#x27;</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line">flag = x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 150</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(str1), <span class="number">2</span>):</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    a = <span class="built_in">int</span>(str1[i])</span><br><span class="line">    b = <span class="built_in">int</span>(str1[(i + <span class="number">1</span>)])</span><br><span class="line">    list2[a][b] = j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 152</span></span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">0</span>][<span class="number">1</span>] != <span class="number">24</span> <span class="keyword">or</span> list2[<span class="number">4</span>][<span class="number">3</span>] != <span class="number">2</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">0</span>][<span class="number">2</span>] != <span class="number">1</span> <span class="keyword">or</span> list2[<span class="number">2</span>][<span class="number">3</span>] != <span class="number">20</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">if</span> list2[<span class="number">1</span>][<span class="number">0</span>] != <span class="number">23</span> <span class="keyword">or</span> list2[<span class="number">3</span>][<span class="number">4</span>] != <span class="number">3</span>:</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 154 ~ 162</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    tnum = <span class="number">0</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        tnum += cla.list2[a][i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tnum != num:</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 164 ~ 172</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">    tnum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        tnum += list2[i][b]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tnum != num:</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 174 ~ 180</span></span><br><span class="line">print(<span class="string">&#x27;Goodjob!&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;The flag is vnctf&#123;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(flag, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;&#125;&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#182</span></span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h1 id="FlipGame"><a href="#FlipGame" class="headerlink" title="FlipGame"></a>FlipGame</h1><p>ida中看到主函数中，有一个16x16的位数组，先是把16进制转10进制，然后翻转上下左右中间。</p><p>解法是暴力搜索第一行的情况，接着对于第i+1行，如果第i行对应位置为0，就在第i+1行的那一位执行翻转操作。这样就能得到解。</p><p>代码的话搜索poj 3279即可，是个noip题目。</p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/ctf/">ctf</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/vnctf/">vnctf</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/17/vnctf21ReWp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>远程线程注入逆向</title>
      <link>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/</link>
      <guid>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/</guid>
      <pubDate>Tue, 16 Mar 2021 09:08:49 GMT</pubDate>
      
      <description>对远程线程注入（CreateRemoteThread）所用到的函数做了一下逆向研究,&lt;br&gt;用native api实现了远程注入</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="远程线程注入逆向"><a href="#远程线程注入逆向" class="headerlink" title="远程线程注入逆向"></a>远程线程注入逆向</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><h3 id="MSDN中的函数定义"><a href="#MSDN中的函数定义" class="headerlink" title="MSDN中的函数定义"></a>MSDN中的函数定义</h3><h4 id="OpenProcess-processthreadsapi-h"><a href="#OpenProcess-processthreadsapi-h" class="headerlink" title="OpenProcess (processthreadsapi.h)"></a>OpenProcess (processthreadsapi.h)</h4><blockquote><h4 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h4><p>HANDLE OpenProcess (<br>    DWORD dwDesiredAccess,<br>    BOOL bInheritHandle,<br>    DWORD dwProcessId);</p><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><p>DLL：Kernel32.dll</p></blockquote><h4 id="NtOpenProcess-ntddk-h"><a href="#NtOpenProcess-ntddk-h" class="headerlink" title="NtOpenProcess (ntddk.h)"></a>NtOpenProcess (ntddk.h)</h4><blockquote><h4 id="Syntax-1"><a href="#Syntax-1" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtOpenProcess (<br>   PHANDLE ProcessHandle,<br>   ACCESS_MASK DesiredAccess,<br>   POBJECT_ATTRIBUTES ObjectAttributes,<br>   PCLIENT_ID ClientId);</p><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><p>Header：ntddk.h (include Ntddk.h, Ntifs.h)</p></blockquote><h4 id="NtAllocateVirtualMemory-ntifs-h"><a href="#NtAllocateVirtualMemory-ntifs-h" class="headerlink" title="NtAllocateVirtualMemory (ntifs.h)"></a>NtAllocateVirtualMemory (ntifs.h)</h4><blockquote><h4 id="Syntax-2"><a href="#Syntax-2" class="headerlink" title="Syntax"></a>Syntax</h4><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtAllocateVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID *BaseAddress,<br>   ULONG_PTR ZeroBits,<br>   PSIZE_T RegionSize,<br>   ULONG AllocationType,<br>   ULONG Protect);</p></blockquote><h3 id="第三方网站中的函数定义"><a href="#第三方网站中的函数定义" class="headerlink" title="第三方网站中的函数定义"></a>第三方网站中的函数定义</h3><h4 id="NtWriteVirtualMemory"><a href="#NtWriteVirtualMemory" class="headerlink" title="NtWriteVirtualMemory"></a>NtWriteVirtualMemory</h4><blockquote><p>__kernel_entry NTSYSCALLAPI NTSTATUS NtQueryVirtualMemory(<br>   HANDLE ProcessHandle,<br>   PVOID BaseAddress,<br>   MEMORY_INFORMATION_CLASS MemoryInformationClass,<br>   PVOID MemoryInformation,<br>   SIZE_T MemoryInformationLength,<br>   PSIZE_T ReturnLength );</p></blockquote><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><h4 id="UNICODE-STRING-ntdef-h"><a href="#UNICODE-STRING-ntdef-h" class="headerlink" title="UNICODE_STRING (ntdef.h)"></a>UNICODE_STRING (ntdef.h)</h4><p>似乎是一种安全的unicode字符串类型，下面是ntdef源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unicode strings are counted 16-bit character strings. If they are</span></span><br><span class="line"><span class="comment">// NULL terminated, Length does not include trailing NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MIDL_PASS</span></span><br><span class="line">    [size_is(MaximumLength / <span class="number">2</span>), length_is((Length) / <span class="number">2</span>) ] USHORT * Buffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">    _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH   Buffer;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MIDL_PASS</span></span></span><br><span class="line">&#125; UNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING *PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> UNICODE_STRING *PCUNICODE_STRING;</span><br><span class="line"><span class="comment">// end_sdfwdm</span></span><br><span class="line"><span class="comment">// end_wudfwdm</span></span><br></pre></td></tr></table></figure><h4 id="OBJECT-ATTRIBUTES-ntdef-h"><a href="#OBJECT-ATTRIBUTES-ntdef-h" class="headerlink" title="OBJECT_ATTRIBUTES (ntdef.h)"></a>OBJECT_ATTRIBUTES (ntdef.h)</h4><p>下面是ntdef源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    HANDLE RootDirectory;</span><br><span class="line">    PUNICODE_STRING ObjectName;</span><br><span class="line">    ULONG Attributes;</span><br><span class="line">    PVOID SecurityDescriptor;        <span class="comment">// Points to type SECURITY_DESCRIPTOR</span></span><br><span class="line">    PVOID SecurityQualityOfService;  <span class="comment">// Points to type SECURITY_QUALITY_OF_SERVICE</span></span><br><span class="line">&#125; OBJECT_ATTRIBUTES;</span><br><span class="line"><span class="keyword">typedef</span> OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;</span><br><span class="line"><span class="keyword">typedef</span> CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;</span><br></pre></td></tr></table></figure><h4 id="CLIENT-ID-MSDN"><a href="#CLIENT-ID-MSDN" class="headerlink" title="CLIENT_ID (MSDN)"></a>CLIENT_ID (MSDN)</h4><p>MSDN的解释是包括进程和线程的id，下面是MSDN中的定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> &#123;</span></span><br><span class="line">HANDLE UniqueProcess;</span><br><span class="line">HANDLE UniqueThread;</span><br><span class="line">&#125; CLIENT_ID;</span><br></pre></td></tr></table></figure><h3 id="文件地址"><a href="#文件地址" class="headerlink" title="文件地址"></a>文件地址</h3><blockquote><p>C:\Windows\System32\kernel32.dll<br>C:\Windows\System32\KernelBase.dll<br>C:\Windows\SysWOW64\kernel32.dll<br>C:\Windows\SysWOW64\KernelBase.dll<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\windows.h<br>C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\ntdef.h</p></blockquote><h2 id="逆向重写OpenProcess（NtOpenProcess）"><a href="#逆向重写OpenProcess（NtOpenProcess）" class="headerlink" title="逆向重写OpenProcess（NtOpenProcess）"></a>逆向重写OpenProcess（NtOpenProcess）</h2><h3 id="在dll中寻找OpenProcess"><a href="#在dll中寻找OpenProcess" class="headerlink" title="在dll中寻找OpenProcess"></a>在dll中寻找OpenProcess</h3><p>在本机的System32\kernel32.dll里没有找到，只找到OpenProcessStub()，这个函数会直接调用OpenProcess。在System32\KernelBase.dll里找到了OpenProcess，然后用ida f5，改了以下符号名是下面这个样子。</p><p>其中ObjectAttributes.Length这个参数有问题，64位是48，32位是24，msdn里是<code>sizeof(OBJECT_ATTRIBUTES)</code>。</p><p>如果有dalao看到这里肯定发现，system32目录下的是64位的dll，但我原本是想找32位的，很尴尬。</p><h3 id="KernelBase"><a href="#KernelBase" class="headerlink" title="KernelBase"></a>KernelBase</h3><p>MSDN上找到一份关于win7的资料[5]，大概意思是把部分kernel32和advapi32的函数移到了kernelbase里，并称kernelbase为low-level binaries，应该是低权限的意思。目的是为了以后的网络工程开发和减少攻击面。</p><h3 id="OpenProcess调用过程（x32）"><a href="#OpenProcess调用过程（x32）" class="headerlink" title="OpenProcess调用过程（x32）"></a>OpenProcess调用过程（x32）</h3><p>在重写OpenProcess改用NtOpenProcess后（详细见下面重新OpenProcess），我重新跟踪了下调用OpenProcess的过程。</p><p><img src="https://s3.ax1x.com/2021/03/16/6y9jbj.png" alt="op32"></p><p>首先main函数call OpenProcess，跳转到kernel.dll；然后jmp到kernelbase.dll；在kernelbase.dll里才是OpenProcess的主要代码，其中会调用ntdll的NtOpenProcess；而NtOpenProcess会调用系统调用。</p><h3 id="OpenProcess调用过程（x64）"><a href="#OpenProcess调用过程（x64）" class="headerlink" title="OpenProcess调用过程（x64）"></a>OpenProcess调用过程（x64）</h3><p>64位和32差不多，先是main call OpenProcess跳转到kernel.dll；然后jmp到kernelbase.dll；kernelbase.dll里是主要代码，不同点是ObjectAttributes.Length的值，以及32位调用的NtOpenProcess，在64中改成了ntdll的ZwOpenProcess；而ZwOpenProcess同样调用了系统调用。</p><p><img src="https://s3.ax1x.com/2021/03/16/6yCuPx.png" alt="op64"></p><h3 id="重写OpenProcess（NtOpenProcess）"><a href="#重写OpenProcess（NtOpenProcess）" class="headerlink" title="重写OpenProcess（NtOpenProcess）"></a>重写OpenProcess（NtOpenProcess）</h3><p>直接引用ntdef.h会引发下面的错误：</p><p>error C2338: Windows headers require the default packing option. Changing this can lead to memory corruption. This diagnostic can be disabled by building with WINDOWS_IGNORE_PACKING_MISMATCH defined.</p><p>最终代替OpenProcess的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR  Buffer;</span><br><span class="line">&#125;UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">ULONG Length;</span><br><span class="line">HANDLE RootDirectory;</span><br><span class="line">PUNICODE_STRING ObjectName;</span><br><span class="line">ULONG Attributes;</span><br><span class="line">PVOID SecurityDescriptor;</span><br><span class="line">PVOID SecurityQualityOfService;</span><br><span class="line">&#125;OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLIENT_ID</span> &#123;</span></span><br><span class="line">HANDLE UniqueProcess;</span><br><span class="line">HANDLE UniqueThread;</span><br><span class="line">&#125;CLIENT_ID, *PCLIENT_ID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span> <span class="params">(WINAPI* PNtOpenProcess)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">PCLIENT_ID ClientId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hTarget = OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), false, pid);</span></span><br><span class="line">HMODULE mdNT = GetModuleHandleW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">PNtOpenProcess NtOpenProcess = (PNtOpenProcess)GetProcAddress(mdNT, <span class="string">&quot;NtOpenProcess&quot;</span>);</span><br><span class="line">OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="keyword">sizeof</span>(OBJECT_ATTRIBUTES) &#125;; <span class="comment">// 0x18</span></span><br><span class="line">CLIENT_ID ClientId = &#123; (HANDLE)pid, <span class="number">0</span> &#125;;</span><br><span class="line">DWORD nts = NtOpenProcess(&amp;hTarget, (PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), &amp;ObjectAttributes, &amp;ClientId);</span><br></pre></td></tr></table></figure><p>其中ObjectAttributes.Length我一开始照抄48（后面才发现，照抄的是64位版本的openprocess。），然后NtOpenProcess给我返回了0xC000000D，MSDN中的说明是传入非法参数，再仔细看Members条目，发现这个参数应该为<code>sizeof(OBJECT_ATTRIBUTES)</code>，vs中调试发现这个结构体的长度为24，修改后就能正常用了。原因是32和64的OBJECT_ATTRIBUTES结构长度不一样。</p><h2 id="R0和R3通信"><a href="#R0和R3通信" class="headerlink" title="R0和R3通信"></a>R0和R3通信</h2><p>后面查资料才知道，windwos程序运行在r3（用户态）层；驱动在r1，r2；系统代码在r0（内核态）层。r0权限最高。</p><p>ntdll提供api使得r3层面的程序能够执行r0层的代码。而ntdll的native api都是成对出现的，分别以Nt和Zw开头。</p><h2 id="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"><a href="#逆向重写VirtualAllocEx（NtAllocateVirtualMemory）" class="headerlink" title="逆向重写VirtualAllocEx（NtAllocateVirtualMemory）"></a>逆向重写VirtualAllocEx（NtAllocateVirtualMemory）</h2><h3 id="KernelBase-dll中的VirtualAllocEx"><a href="#KernelBase-dll中的VirtualAllocEx" class="headerlink" title="KernelBase.dll中的VirtualAllocEx"></a>KernelBase.dll中的VirtualAllocEx</h3><p>VirtualAllocEx会直接调用VirtualAllocExNuma；然后VirtualAllocExNuma调用NtAllocateVirtualMemory。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span> <span class="params">(WINAPI* PNtAllocateVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID* BaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG_PTR ZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">PSIZE_T RegionSize,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG AllocationType,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG Protect</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pszPathname = (PWSTR)VirtualAllocEx(hTarget, NULL, pathnameLen, MEM_COMMIT, PAGE_READWRITE);</span></span><br><span class="line">PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(mdNT, <span class="string">&quot;NtAllocateVirtualMemory&quot;</span>);</span><br><span class="line">nts = NtAllocateVirtualMemory(hTarget, (PVOID*)&amp;pszPathname, <span class="number">0</span>, (SIZE_T*)&amp;pathnameLen, MEM_COMMIT &amp; <span class="number">0xFFFFFFC0</span>, PAGE_READWRITE);</span><br></pre></td></tr></table></figure><h2 id="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"><a href="#逆向重写WriteProcessMemory（NtWriteVirtualMemory）" class="headerlink" title="逆向重写WriteProcessMemory（NtWriteVirtualMemory）"></a>逆向重写WriteProcessMemory（NtWriteVirtualMemory）</h2><h3 id="KernelBase-dll中的WriteProcessMemory"><a href="#KernelBase-dll中的WriteProcessMemory" class="headerlink" title="KernelBase.dll中的WriteProcessMemory"></a>KernelBase.dll中的WriteProcessMemory</h3><p>WriteProcessMemory中调用了NtQueryVirtualMemory，NtProtectVirtualMemory，NtWriteVirtualMemory，NtFlushInstructionCache。后三个在MSDN中似乎都没有资料。</p><p>其中 NtQueryVirtualMemory 用于获取虚拟内存的属性。</p><p>在第三方网站查询得到 NtProtectVirtualMemory[7] 用于改变虚拟内存区域的保护状态。</p><p>关于 NtFlushInstructionCache 的资料没有找到多少，说是用于刷新指令缓存，不知道具体有什么用。</p><p>同样在第三方网站查询得到 NtWriteVirtualMemory[8] 用于写入内存。所以只需要直接调用这个即可。</p><h3 id="重写-1"><a href="#重写-1" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PNtWriteVirtualMemory)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID BaseAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG BufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG NumberOfBytesWritten</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WriteProcessMemory(hTarget, (LPVOID)memoryAddr, buf, bufSize, &amp;byw);</span></span><br><span class="line">PNtWriteVirtualMemory NtWriteVirtualMemory = (PNtWriteVirtualMemory)GetProcAddress(mdNT, <span class="string">&quot;NtWriteVirtualMemory&quot;</span>);</span><br><span class="line">NtWriteVirtualMemory(hTarget, memoryAddr, buf, bufSize, &amp;byw);</span><br></pre></td></tr></table></figure><h2 id="逆向重写LoadLibraryExW（LdrLoadDll）"><a href="#逆向重写LoadLibraryExW（LdrLoadDll）" class="headerlink" title="逆向重写LoadLibraryExW（LdrLoadDll）"></a>逆向重写LoadLibraryExW（LdrLoadDll）</h2><p>32位下调用过程如下，不管调用哪个版本，最终都会去到LoadLibraryExW。</p><p>LoadLibraryA -&gt; LoadLibraryExA -&gt;LoadLibraryExW，LoadLibraryW -&gt; LoadLibraryExW</p><h3 id="KernelBase-dll中的LoadLibraryExW"><a href="#KernelBase-dll中的LoadLibraryExW" class="headerlink" title="KernelBase.dll中的LoadLibraryExW"></a>KernelBase.dll中的LoadLibraryExW</h3><p>首先通过传入的dwFlags参数确认传入的dll名称是不是unicode编码，不是就设置错误代码为0xC000000D（传入参数非法）。</p><p>然后转换成UNICODE_STRING（RtlInitUnicodeString）。</p><p>转换后会进行检查，去掉unicode字符串末尾的空格。如果全是空格同样会设置错误代码为0xC000000D。</p><p>接着有一段代码会调用 LdrGetDllPath，这段代码如果调用 LoadLibraryW 进入的 LoadLibraryExW 不会触发。</p><p>然后又有一系列从 LoadLibraryW 进入不会触发的if语句。</p><p>最后调用 LdrLoadDll。</p><p>需要注意的是，要选择Release模式，debug模式会出问题，不能正确获得ShellCode地址。</p><h3 id="重写-2"><a href="#重写-2" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __declspec(naked) ShellCode(PVOID addr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// para 3 UNICODE_STRING pathname</span></span><br><span class="line">    <span class="comment">// [addr+0x0] 2:  USHORT  Length</span></span><br><span class="line">    <span class="comment">// [addr+0x2] 2:  USHORT  MaximumLength</span></span><br><span class="line">    <span class="comment">// [addr+0x4] 4:  PWSTR   Buffer        = addr+8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x8] 0x14: wchar_t dllPathname</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// para 2</span></span><br><span class="line">    <span class="comment">// [addr+0x98] 4: ULONG LoadFlags = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// para 4</span></span><br><span class="line">    <span class="comment">// [addr+0x9C] 4: PVOID BaseAddress = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x100] 4: PVOID LdrLoadDll</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [addr+0x200] : shellcode</span></span><br><span class="line">__asm &#123;</span><br><span class="line">pushad;</span><br><span class="line">mov eax, addr;</span><br><span class="line"><span class="comment">// para 4</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">add ebx, <span class="number">0x9c</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 3</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 2</span></span><br><span class="line">mov ebx, eax;</span><br><span class="line">add ebx, <span class="number">0x98</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// para 1</span></span><br><span class="line">mov ebx, <span class="number">1</span>;</span><br><span class="line">push ebx;</span><br><span class="line"><span class="comment">// call LdrLoadDll</span></span><br><span class="line">add eax, <span class="number">0x100</span>;</span><br><span class="line">mov edx, [eax];</span><br><span class="line">call edx;</span><br><span class="line">popad;</span><br><span class="line">mov eax, addr;</span><br><span class="line">add eax, <span class="number">0x9C</span>;</span><br><span class="line">mov eax, [eax];</span><br><span class="line">ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入参数及shellcode"><a href="#写入参数及shellcode" class="headerlink" title="写入参数及shellcode"></a>写入参数及shellcode</h4><p>这里需要用NtWriteVirtualMemory写入参数及shellcode。</p><p>第三个参数 UNICODE_STRING pathname 我直接选择自己构建，MaximumLength就是dll路径字符串的字节数（包括末尾的零），而Length必须是字符串不包括末尾\x0\x0的字节数，否则会LdrLoadDll会找不到dll并返回0xC0000135。</p><h2 id="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"><a href="#逆向重写CreateRemoteThreadEx（NtCreateThreadEx）" class="headerlink" title="逆向重写CreateRemoteThreadEx（NtCreateThreadEx）"></a>逆向重写CreateRemoteThreadEx（NtCreateThreadEx）</h2><h3 id="KernelBase-dll中的CreateRemoteThreadEx"><a href="#KernelBase-dll中的CreateRemoteThreadEx" class="headerlink" title="KernelBase.dll中的CreateRemoteThreadEx"></a>KernelBase.dll中的CreateRemoteThreadEx</h3><p>CreateRemoteThread会直接调用CreateRemoteThreadEx</p><p>然后CreateRemoteThreadEx会搞一堆奇奇怪怪的检测，并调用NtCreateThreadEx。</p><p>在网上找到定义[9]，照着定义和ida写了下。其中调用了个BaseFormatObjectAttributes，但传了两个零进去发现其实什么也没干。</p><h3 id="重写-3"><a href="#重写-3" class="headerlink" title="重写"></a>重写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PNtCreateThreadEx)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE hThread,</span></span></span><br><span class="line"><span class="function"><span class="params">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG StackZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG SizeOfStackCommit,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG SizeOfStackReserve,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpBytesBuffer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">PNtCreateThreadEx NtCreateThreadEx = (PNtCreateThreadEx)GetProcAddress(mdNT, <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line">nts = NtCreateThreadEx(</span><br><span class="line">    &amp;hDll,</span><br><span class="line">    <span class="number">0x1FFFFF</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    hTarget,</span><br><span class="line">    (LPTHREAD_START_ROUTINE)(pVirtualMemory + <span class="number">0x200</span>),</span><br><span class="line">    (PVOID)pVirtualMemory,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="用RtlCreateUserThread代替CreateRemoteThread"><a href="#用RtlCreateUserThread代替CreateRemoteThread" class="headerlink" title="用RtlCreateUserThread代替CreateRemoteThread"></a>用RtlCreateUserThread代替CreateRemoteThread</h2><p>据说RtlCreateUserThread是NtCreateThread的一个小型封装。抄了一下Metasploit的代码[11]。</p><p>Metasploit会先用CraeteRemoteThread，没有足够空间时再使用RtlCreateUserThread。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">long</span><span class="params">(WINAPI* PRtlCreateUserThread)</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PSECURITY_DESCRIPTOR SecurityDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">BOOLEAN CreateSuspended,</span></span></span><br><span class="line"><span class="function"><span class="params">ULONG StackZeroBits,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG StackReserved,</span></span></span><br><span class="line"><span class="function"><span class="params">PULONG StackCommit,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID StartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">PVOID StartParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">PCLIENT_ID ClientID</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">PRtlCreateUserThread RtlCreateUserThread = (PRtlCreateUserThread)GetProcAddress(mdNT, <span class="string">&quot;RtlCreateUserThread&quot;</span>);</span><br><span class="line">nts = RtlCreateUserThread(</span><br><span class="line">    hTarget,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (LPTHREAD_START_ROUTINE)(pVirtualMemory + <span class="number">0x200</span>),</span><br><span class="line">    (PVOID)pVirtualMemory,</span><br><span class="line">    &amp;hDll,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] UNICODE_STRING ：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_unicode_string</a></p><p>[2] OBJECT_ATTRIBUTES：<a href="https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes">https://docs.microsoft.com/en-us/windows/win32/api/ntdef/ns-ntdef-_object_attributes</a></p><p>[3] CLIENT_ID：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057</a></p><p>[4] NtOpenProcess：<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-ntopenprocess</a></p><p>[5] New Low-Level Binaries（win7）：<a href="https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries">https://docs.microsoft.com/en-us/windows/win32/win7appqual/new-low-level-binaries</a></p><p>[6] r0和r3之间的通信：<a href="https://blog.csdn.net/qq_33526144/article/details/103503011">https://blog.csdn.net/qq_33526144/article/details/103503011</a></p><p>[7] NtQueryVirtualMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtProtectVirtualMemory.htm</a></p><p>[8] NtWriteProcessMemory：<a href="http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm">http://www.codewarrior.cn/ntdoc/winnt/mm/NtWriteVirtualMemory.htm</a></p><p>[9] NtCreateThread：<a href="https://securityxploded.com/ntcreatethreadex.php">https://securityxploded.com/ntcreatethreadex.php</a></p><p>[10] RtlCreateUserThread：<a href="https://undocumented.ntinternals.net/index.html?page=UserMode/Undocumented%20Functions/Executable%20Images/RtlCreateUserThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FExecutable%20Images%2FRtlCreateUserThread.html</a></p><p>[11] RtlCreateUserThread Metasploit例子：<a href="https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77">https://github.com/rapid7/meterpreter/blob/6d43284689240f4261cae44a47f0fb557c1dde27/source/common/arch/win/remote_thread.c#L77</a></p><p>[12] RtlCreateUserThread mimikatz例子：<a href="https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59">https://github.com/gentilkiwi/mimikatz/blob/d5676aa66cb3f01afc373b0a2f8fcc1a2822fd27/modules/kull_m_remotelib.c#L59</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/windows/">windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/16/dllRemoteInject/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>windows核心编程 dll笔记</title>
      <link>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/</link>
      <guid>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/</guid>
      <pubDate>Tue, 16 Mar 2021 08:52:35 GMT</pubDate>
      
      <description>看windows核心编程dll注入部分的时候做的一些笔记</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="windows核心编程-dll笔记"><a href="#windows核心编程-dll笔记" class="headerlink" title="windows核心编程 dll笔记"></a>windows核心编程 dll笔记</h1><h2 id="构建及使用dll"><a href="#构建及使用dll" class="headerlink" title="构建及使用dll"></a>构建及使用dll</h2><p>以下是核心编程的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\Mylib\MyLib.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLIB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">MYLIB <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function">MYLIB <span class="keyword">int</span> <span class="title">DllFun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\Mylib\MyLib1.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLIB extern <span class="meta-string">&quot;C&quot;</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dll_num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DllFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dll_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .\MyExe.cpp */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MyLib\MyLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dll_num = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; DllFun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>extern “C”修饰符用于指明使用C++。</p><h2 id="载入dll模块"><a href="#载入dll模块" class="headerlink" title="载入dll模块"></a>载入dll模块</h2><h3 id="显式载入"><a href="#显式载入" class="headerlink" title="显式载入"></a>显式载入</h3><p>将dll映射到进程的地址空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibrary</span><span class="params">(PCTSTR pszDLLPathName)</span></span>;</span><br><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryEx</span><span class="params">(PCTSTR pszDLLPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HANDLE hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">                      DWORD dwFlags)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值是被映射到的虚拟内存地址。（此处HMODULE等价于HINSTANCE）</p><p>通过GetLastError确定是否成功载入。</p><h3 id="显式链接到导出符号"><a href="#显式链接到导出符号" class="headerlink" title="显式链接到导出符号"></a>显式链接到导出符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(HMODULE hInstDll, PCSTR pszSymbolName)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="显式卸载"><a href="#显式卸载" class="headerlink" title="显式卸载"></a>显式卸载</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">FreeLibrary</span><span class="params">(HMODULE hInstDll)</span></span>;</span><br><span class="line"><span class="function">VOID <span class="title">FreeLivraryAndExitThread</span><span class="params">(HMODULE hInstDll, DWORD dwExitCode)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="dll搜索顺序"><a href="#dll搜索顺序" class="headerlink" title="dll搜索顺序"></a>dll搜索顺序</h3><ul><li>当前目录</li><li>windows系统目录</li><li>16位windows系统目录（windows目录下的system子目录）</li><li>windows目录</li><li>path环境变量中的目录</li></ul><h2 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain"></a>DllMain</h2><h3 id="fdwReason"><a href="#fdwReason" class="headerlink" title="fdwReason"></a>fdwReason</h3><p><strong>DLL_PROCESS_ATTACH：</strong><br>第一次将DLL<strong>映射到进程中</strong>时，会调用DllMain并传入该信号。<br>通常此时应该通过HeapCreate创建需要的堆。<br>返回值用于表示是否初始化成功。</p><p><strong>DLL_THREAD_ATTACH：</strong><br>进程创建一个线程时触发。</p><p><strong>DLL_THREAD_DETACH：</strong><br>ExitThread触发。</p><p><strong>DLL_PROCESS_DETACH：</strong><br>撤销映射时传入该信号。<br>通常执行HeapDestroy销毁初始化时创建的堆。</p><h2 id="模块的基地址重定位"><a href="#模块的基地址重定位" class="headerlink" title="模块的基地址重定位"></a>模块的基地址重定位</h2><p>重定位段(relocation section)包含一个字节偏移量的列表，记录机器指令的内存地址，用于需要重定位时遍历修改内存映像中的地址。</p><h2 id="RemoteInject（CreateRemoteThread）"><a href="#RemoteInject（CreateRemoteThread）" class="headerlink" title="RemoteInject（CreateRemoteThread）"></a>RemoteInject（CreateRemoteThread）</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ul><li><p>获取目标进程pid，并打开目标进程。</p></li><li><p>在目标进程中申请空间，写入注入dll的路径。</p></li><li><p>获取LoadLibrary在Kernel32.dll的真实地址。</p></li><li><p>通过远程创建线程，在目标进程中创建一个线程，执行LoadLibrary(dllPathname)。</p></li><li><p>释放申请的空间，并关闭句柄。</p></li></ul><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>因为是在目标进程中执行LoadLibrary(dllPathname)的，所以需要先把dll路径写入目标进程中，并作为LoadLibrary的参数。</p><p>直接调用LoadLibrary时，链接器会生成一个调用，调用导入段中的一个转换函数。即先跳转到转换函数，再跳转到实际函数。<br>而转换函数在不同进程中是会变的，但Kernel32.dll在所有进程中映射的地址是一样的，所以需要获取LoadLibrary在Kernel32.dll中的地址。</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">RemoteInject.cpp</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(WCHAR* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">wchar_t</span> targetName[<span class="number">20</span>] = <span class="string">L&quot;Target.exe&quot;</span>;</span><br><span class="line"><span class="keyword">wchar_t</span> dllPathname[] = <span class="string">L&quot;E:\\MyDll.dll&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pathnameLen = (<span class="number">1</span> + lstrlenW(dllPathname)) * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>);</span><br><span class="line">DWORD pid = <span class="number">0</span>, byw = <span class="number">0</span>;</span><br><span class="line">HANDLE hTarget = <span class="number">0</span>, hDll = <span class="number">0</span>;</span><br><span class="line">PWSTR pszPathname = <span class="number">0</span>;</span><br><span class="line">PTHREAD_START_ROUTINE realAddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line"><span class="comment">// 1 get pid</span></span><br><span class="line">pid = GetPidByName(targetName);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Get pid failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pid:&quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 open process</span></span><br><span class="line">hTarget = OpenProcess((PROCESS_CREATE_THREAD | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION), <span class="literal">false</span>, pid);</span><br><span class="line"><span class="keyword">if</span> (hTarget == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Open process failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 alloc memory for dll pathname</span></span><br><span class="line">pszPathname = (PWSTR)VirtualAllocEx(hTarget, <span class="literal">NULL</span>, pathnameLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pszPathname == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:Alloc memory failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pathname addr: &quot;</span> &lt;&lt; pszPathname &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 write dll pathname</span></span><br><span class="line">WriteProcessMemory(hTarget, (LPVOID)pszPathname, dllPathname, pathnameLen, &amp;byw);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;dll pathname(len, write len): &quot;</span> &lt;&lt; pathnameLen &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; byw &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 get the real address of LoadLibraryW in Kernel32.dll</span></span><br><span class="line">HMODULE mh = GetModuleHandleW(<span class="string">L&quot;Kernel32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (mh == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:kernel\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line">realAddr = (PTHREAD_START_ROUTINE)GetProcAddress(mh, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 create a remote thread to call LoadLibraryW(dllPathname)</span></span><br><span class="line">hDll = CreateRemoteThread(hTarget, <span class="literal">NULL</span>, <span class="number">0</span>, realAddr, pszPathname, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hDll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;e:create remote thread failed\n&quot;</span>;</span><br><span class="line">__leave;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hDll: &quot;</span> &lt;&lt; hDll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait</span></span><br><span class="line">WaitForSingleObject(hDll, INFINITE);</span><br><span class="line">&#125;</span><br><span class="line">__finally &#123;</span><br><span class="line"><span class="comment">// clean</span></span><br><span class="line"><span class="keyword">if</span> (hDll != <span class="literal">NULL</span>) &#123;</span><br><span class="line">CloseHandle(hDll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hTarget != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (pszPathname != <span class="literal">NULL</span>)</span><br><span class="line">VirtualFreeEx(hTarget, pszPathname, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"></span><br><span class="line">CloseHandle(hTarget);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(WCHAR* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hsnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hsnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">printf_s(<span class="string">&quot;CreateToolhelp32Snapshot error!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROCESSENTRY32 pe&#123;&#125;;</span><br><span class="line">pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = Process32First(hsnapshot, &amp;pe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (wcscmp(pe.szExeFile, name) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line">flag = Process32Next(hsnapshot, &amp;pe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(hsnapshot);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImageWalk"><a href="#ImageWalk" class="headerlink" title="ImageWalk"></a>ImageWalk</h2><p>遍历内存区块查询对应的信息</p><h3 id="MEMORY-BASIC-INFORMATION"><a href="#MEMORY-BASIC-INFORMATION" class="headerlink" title="MEMORY_BASIC_INFORMATION"></a>MEMORY_BASIC_INFORMATION</h3><p>AllocationBase：内存单元起始地址</p><p>BaseAddress：模块基地址</p><p>RegionSize：模块所以页面的大小</p><h3 id="C6262-堆栈溢出警告"><a href="#C6262-堆栈溢出警告" class="headerlink" title="C6262 堆栈溢出警告"></a>C6262 堆栈溢出警告</h3><p>C6262：函数使用了堆栈的“26300”个字节: 超过了 /analyze:stacksize ‘16384’。 请考虑将某些数据移到堆中。</p><p>其中有一个变量为 char szBuf[260 * 100]，260是路径长度最大值，100是个数，这里减少下个数避免这个警告。</p><p>其他解决方式如malloc或new就不再深究了。</p><h2 id="小笔记"><a href="#小笔记" class="headerlink" title="小笔记"></a>小笔记</h2><p>__try和try：据说Release模式下，如果没有throw模块，vc会优化掉try catch</p><p>线性地址：逻辑地址（偏移）+ 基地址</p><p>HMODULE：模块句柄，win32下通常是被载入模块的线性地址</p><p>MAX_PATH：宏常量，通常为260，代表编译器支持的最长路径长度</p><p>sz：string zero，表示以零结尾的字符串，即c字符串</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>C6262：<a href="https://blog.csdn.net/mxclxp/article/details/7991127">https://blog.csdn.net/mxclxp/article/details/7991127</a></p><p>随书代码下载页面：<a href="https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/">https://www.wintellect.com/windows-via-cc-by-jeffrey-richter-and-christopher-nasarre/</a></p><p>随书代码下载地址：<a href="https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip">https://www.wintellect.com/wp-content/uploads/2017/11/Windows-via-C-Code-January-29-2008.zip</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/windows/">windows</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/windows/">windows</category>
      
      <category domain="https://windgodm.github.io/blog/tags/dll/">dll</category>
      
      <category domain="https://windgodm.github.io/blog/tags/windows-via-c/">windows_via_c</category>
      
      <category domain="https://windgodm.github.io/blog/tags/note/">note</category>
      
      
      <comments>https://windgodm.github.io/blog/2021/03/16/winViaC-dll/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>geek20</title>
      <link>https://windgodm.github.io/blog/2020/12/08/geek20/</link>
      <guid>https://windgodm.github.io/blog/2020/12/08/geek20/</guid>
      <pubDate>Tue, 08 Dec 2020 09:48:04 GMT</pubDate>
      
      <description>2020年极客大挑战部分wp（除了web基本都有）</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="/blog/ctf_wp/geek20.html">geek challenge 20th</a></p>]]></content:encoded>
      
      
      <category domain="https://windgodm.github.io/blog/categories/ctf/">ctf</category>
      
      
      <category domain="https://windgodm.github.io/blog/tags/ctf/">ctf</category>
      
      <category domain="https://windgodm.github.io/blog/tags/geek-challenge/">geek_challenge</category>
      
      <category domain="https://windgodm.github.io/blog/tags/wp/">wp</category>
      
      <category domain="https://windgodm.github.io/blog/tags/re/">re</category>
      
      <category domain="https://windgodm.github.io/blog/tags/pwn/">pwn</category>
      
      <category domain="https://windgodm.github.io/blog/tags/crypt/">crypt</category>
      
      <category domain="https://windgodm.github.io/blog/tags/misc/">misc</category>
      
      
      <comments>https://windgodm.github.io/blog/2020/12/08/geek20/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
